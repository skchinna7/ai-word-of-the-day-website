<!DOCTYPE html>
<html>
<head>
    <!-- Character encoding -->
    <meta charset="UTF-8">
    <!-- Viewport for responsive design -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Panel</title><!-- Page title (also in <title>) -->
    <meta name="title" content="Word of the Day - Learn New Words Daily">
    <!-- Page description for search engines -->
    <meta name="description" content="Discover a new word every day with definitions, examples, and pronunciation guides.">
    <!-- Keywords (less important now) -->
    <meta name="keywords" content="word of the day, vocabulary, learning, english words, dictionary">
    <!-- Author -->
    <meta name="author" content="Your Name or Organization">
    <!-- Robots directive -->
    <meta name="robots" content="index, follow">
    <!-- Open Graph protocol -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.wotd.in/">
    <meta property="og:title" content="Word of the Day - Learn New Words Daily">
    <meta property="og:description" content="Discover a new word every day with definitions, examples, and pronunciation guides.">
    <meta property="og:image" content="https://www.wotd.in/images/logo.jpg">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://yourwebsite.com/">
    <meta name="twitter:title" content="Word of the Day - Learn New Words Daily">
    <meta name="twitter:description" content="Discover a new word every day with definitions, examples, and pronunciation guides.">
    <meta name="twitter:image" content="https://yourwebsite.com/images/logo.jpg">

        <!-- Prevent XSS attacks -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- Cache control -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <!-- Favicon -->
    <link rel="icon" type="image/jpg" href="images/logo.jpg">
    <link rel="icon" type="image/jpg" href="images/logo.jpg" sizes="32x32">
    <link rel="stylesheet" href="css/admin.css">
    <link rel="canonical" href="https://www.wotd.in/index/">
    <link rel="alternate" hreflang="es" href="https://www.wotd.in/es/">
    <link rel="alternate" hreflang="fr" href="https://www.wotd.in/fr/"></head>
<body>
    <div id="notLoggedIn" class="denied" style="display:none;">
        <h1>üîê Login Required</h1>
        <p>You must be logged in as admin to access this page.</p>
        <p style="margin-top: 20px;">
            <a href="login.html">Login</a> | <a href="index.html">Go Home</a>
        </p>
    </div>

    <div id="adminPanel" style="display:none;">
        <h1>üéõÔ∏è Admin Panel</h1>
        <div class="user-info">
            <div>
                Logged in as: <strong id="userEmail">Loading...</strong>
                <div style="margin-top: 10px;">
                    <span class="admin-stat-badge">
                        üìö <strong id="wordCountAdmin">0</strong> Total Words
                    </span>
                </div>
            </div>
            <div>
                <a href="index.html" style="margin-right: 10px;">‚Üê Home</a>
                <button id="logoutBtn" style="padding: 8px 16px;">Logout</button>
            </div>
        </div>
        
        <!-- Add this after the header, before search bar -->
        <div class="stats-banner">
            <div class="stat-box">
                <div class="stat-number" id="totalWords">0</div>
                <div class="stat-label">Total Words</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="totalViews">0</div>
                <div class="stat-label">Total Views</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="totalSubscribers">0</div>
                <div class="stat-label">Subscribers</div>
            </div>
        </div>

        <div class="form-container">
            <h2 id="formTitle">Add New Word</h2>
            <form id="wordForm">
                <input type="hidden" id="editId">
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Word *</label>
                        <input type="text" id="word" required>
                        <button type="button" class="btn-secondary btn-full-width" id="autoFetchBtn">
                            ü§ñ Auto-Fill All Details
                        </button>
                        <div id="fetchStatus" style="margin-top: 10px; font-size: 14px;"></div>
                    </div>
                    
                    <div class="form-group">
                        <label>Scheduled Date *</label>
                        <input type="date" id="scheduled" required>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Phonetic (e.g., /s…ôÀàr…õnd…™p…™ti/)</label>
                        <input type="text" id="phonetic" placeholder="Will auto-fill">
                    </div>
                    
                    <div class="form-group">
                        <label>Pronunciation (e.g., ser-en-dip-i-ty)</label>
                        <input type="text" id="pronunciation" placeholder="Will auto-fill">
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label>Part of Speech</label>
                        <select id="partOfSpeech">
                            <option value="">Auto-detect</option>
                            <option value="noun">Noun</option>
                            <option value="verb">Verb</option>
                            <option value="adjective">Adjective</option>
                            <option value="adverb">Adverb</option>
                            <option value="pronoun">Pronoun</option>
                            <option value="preposition">Preposition</option>
                            <option value="conjunction">Conjunction</option>
                            <option value="interjection">Interjection</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Synonyms (comma separated)</label>
                        <input type="text" id="synonyms" placeholder="e.g., happy, joyful, cheerful">
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Antonyms (comma separated)</label>
                    <input type="text" id="antonyms" placeholder="e.g., sad, unhappy, miserable">
                </div>
                
                <div class="form-group">
                    <label>Meaning *</label>
                    <textarea id="meaning" required></textarea>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button type="submit" id="submitBtn">Add Word</button>
                    <button type="button" class="btn-secondary" id="cancelBtn" style="display: none;">Cancel</button>
                </div>
            </form>
            <div id="msg" style="display:none"></div>
        </div>
        
        <div class="table-container">
            <h2>All Words</h2>
            <div id="list">Loading...</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        const sb = window.supabase.createClient(
            "https://qzatavslhtkioivemwlk.supabase.co",
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InF6YXRhdnNsaHRraW9pdmVtd2xrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1MzIyMTYsImV4cCI6MjA4NjEwODIxNn0.LaNyj8T6VYGMMbuyX-Fg_6Fm6yIhPLTW0enYd6sNdGE",
            {
                auth: {
                    persistSession: true,
                    autoRefreshToken: true
                }
            }
        );
        
        let isEditing = false;
        
        async function checkAuth() {
            const { data: { session } } = await sb.auth.getSession();
            
            if (!session) {
                document.getElementById('notLoggedIn').style.display = 'block';
                document.getElementById('adminPanel').style.display = 'none';
                return false;
            }
            
            checkAuth().then(ok => { 
                if(ok) {
                    loadWords();
                    loadWordCount();  // ‚Üê ADD THIS LINE
                    }
            });

            document.getElementById('notLoggedIn').style.display = 'none';
            document.getElementById('adminPanel').style.display = 'block';
            document.getElementById('userEmail').textContent = session.user.email;
            return true;
        }
        
        document.getElementById('logoutBtn').addEventListener('click', async function() {
            await sb.auth.signOut();
            window.location.href = 'index.html';
        });
        
        // Auto-fetch all word details from dictionary API
        // Enhanced Auto-fetch function with better synonym/antonym extraction
        document.getElementById('autoFetchBtn').addEventListener('click', async function() {
            const wordInput = document.getElementById('word').value.trim();
            const fetchStatus = document.getElementById('fetchStatus');
            
            if (!wordInput) {
                fetchStatus.innerHTML = '<span style="color: #f44336;">‚ö†Ô∏è Please enter a word first</span>';
                return;
            }
            
            fetchStatus.innerHTML = '<span style="color: #2196F3;">üîÑ Fetching from multiple sources...</span>';
            
            try {
                // Fetch from Free Dictionary API
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${wordInput}`);
                
                if (!response.ok) {
                    throw new Error('Word not found in dictionary');
                }
                
                const data = await response.json();
                
                if (data && data[0]) {
                    const entry = data[0];
                    let allSynonyms = new Set();
                    let allAntonyms = new Set();
                    
                    // Get phonetic
                    if (entry.phonetic) {
                        document.getElementById('phonetic').value = entry.phonetic;
                    } else if (entry.phonetics && entry.phonetics.length > 0) {
                        for (let phonetic of entry.phonetics) {
                            if (phonetic.text) {
                                document.getElementById('phonetic').value = phonetic.text;
                                break;
                            }
                        }
                    }
                    
                    // Create pronunciation from phonetic
                    const phoneticVal = document.getElementById('phonetic').value;
                    if (phoneticVal) {
                        const simplified = phoneticVal
                            .replace(/[\/\[\]]/g, '')
                            .replace(/Àà/g, '-')
                            .replace(/Àå/g, '')
                            .replace(/Àê/g, '');
                        document.getElementById('pronunciation').value = simplified;
                    }
                    
                    // Process ALL meanings to get comprehensive synonyms/antonyms
                    if (entry.meanings && entry.meanings.length > 0) {
                        // Use the FIRST meaning for primary definition and part of speech
                        const firstMeaning = entry.meanings[0];
                        
                        // Part of speech
                        if (firstMeaning.partOfSpeech) {
                            document.getElementById('partOfSpeech').value = firstMeaning.partOfSpeech;
                        }
                        
                        // Meaning/Definition
                        if (firstMeaning.definitions && firstMeaning.definitions[0]) {
                            document.getElementById('meaning').value = firstMeaning.definitions[0].definition;
                        }
                        
                        // Collect synonyms and antonyms from ALL meanings
                        for (let meaning of entry.meanings) {
                            // Top-level synonyms
                            if (meaning.synonyms && meaning.synonyms.length > 0) {
                                meaning.synonyms.forEach(s => allSynonyms.add(s));
                            }
                            
                            // Top-level antonyms
                            if (meaning.antonyms && meaning.antonyms.length > 0) {
                                meaning.antonyms.forEach(a => allAntonyms.add(a));
                            }
                            
                            // Definition-level synonyms and antonyms
                            if (meaning.definitions) {
                                for (let def of meaning.definitions) {
                                    if (def.synonyms && def.synonyms.length > 0) {
                                        def.synonyms.forEach(s => allSynonyms.add(s));
                                    }
                                    if (def.antonyms && def.antonyms.length > 0) {
                                        def.antonyms.forEach(a => allAntonyms.add(a));
                                    }
                                }
                            }
                        }
                    }
                    
                    // Set synonyms (limit to 10 most relevant)
                    if (allSynonyms.size > 0) {
                        const synonymsArray = Array.from(allSynonyms).slice(0, 10);
                        document.getElementById('synonyms').value = synonymsArray.join(', ');
                    }
                    
                    // Set antonyms (limit to 10 most relevant)
                    if (allAntonyms.size > 0) {
                        const antonymsArray = Array.from(allAntonyms).slice(0, 10);
                        document.getElementById('antonyms').value = antonymsArray.join(', ');
                    }
                    
                    // Try to fetch more synonyms from Thesaurus API if needed
                    if (allSynonyms.size === 0) {
                        try {
                            const thesaurusResponse = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${wordInput}`);
                            if (thesaurusResponse.ok) {
                                const thesaurusData = await thesaurusResponse.json();
                                // Process thesaurus data...
                                console.log('Thesaurus data:', thesaurusData);
                            }
                        } catch (e) {
                            console.log('Thesaurus lookup failed');
                        }
                    }
                    
                    const synCount = allSynonyms.size;
                    const antCount = allAntonyms.size;
                    
                    fetchStatus.innerHTML = `
                        <span style="color: #4CAF50;">
                            ‚úÖ Loaded successfully!<br>
                            Found: ${synCount} synonyms, ${antCount} antonyms
                        </span>
                    `;
                    setTimeout(() => fetchStatus.innerHTML = '', 5000);
                    
                } else {
                    throw new Error('No data available');
                }
            } catch (error) {
                console.error('Fetch error:', error);
                fetchStatus.innerHTML = `
                    <span style="color: #ff9800;">
                        ‚ö†Ô∏è Could not fetch all details automatically.<br>
                        Please enter manually or try a different spelling.
                    </span>
                `;
            }
        });
        
        document.getElementById('wordForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const w = document.getElementById('word').value.trim();
            const m = document.getElementById('meaning').value.trim();
            const s = document.getElementById('scheduled').value;
            const phonetic = document.getElementById('phonetic').value.trim();
            const pronunciation = document.getElementById('pronunciation').value.trim();
            const partOfSpeech = document.getElementById('partOfSpeech').value;
            const synonymsStr = document.getElementById('synonyms').value.trim();
            const antonymsStr = document.getElementById('antonyms').value.trim();
            const editId = document.getElementById('editId').value;
            const msg = document.getElementById('msg');
            const submitBtn = document.getElementById('submitBtn');
            
            submitBtn.disabled = true;
            submitBtn.textContent = isEditing ? 'Updating...' : 'Adding...';
            
            try {
                const wordData = {
                    word: w, 
                    meaning: m, 
                    scheduled_for: s,
                    phonetic: phonetic || null,
                    pronunciation: pronunciation || null,
                    part_of_speech: partOfSpeech || null,
                    synonyms: synonymsStr ? synonymsStr.split(',').map(x => x.trim()) : null,
                    antonyms: antonymsStr ? antonymsStr.split(',').map(x => x.trim()) : null
                };
                
                let error;
                
                if (isEditing && editId) {
                    ({ error } = await sb.from('words').update(wordData).eq('id', editId));
                } else {
                    ({ error } = await sb.from('words').insert(wordData));
                }
                
                if (error) throw error;
                
                msg.className = 'message success';
                msg.textContent = isEditing ? '‚úÖ Word updated!' : '‚úÖ Word added!';
                document.getElementById('wordForm').reset();
                document.getElementById('scheduled').valueAsDate = new Date();
                cancelEdit();
                loadWords();
                
            } catch (error) {
                console.error('Error:', error);
                msg.className = 'message error';
                msg.textContent = '‚ùå ' + error.message;
            }
            
            msg.style.display = 'block';
            setTimeout(() => msg.style.display = 'none', 4000);
            submitBtn.disabled = false;
            submitBtn.textContent = isEditing ? 'Update Word' : 'Add Word';
        });
        
        window.editWord = function(id) {
            sb.from('words').select('*').eq('id', id).single()
                .then(({ data, error }) => {
                    if (error) throw error;
                    
                    isEditing = true;
                    document.getElementById('formTitle').textContent = 'Edit Word';
                    document.getElementById('editId').value = data.id;
                    document.getElementById('word').value = data.word;
                    document.getElementById('meaning').value = data.meaning;
                    document.getElementById('scheduled').value = data.scheduled_for;
                    document.getElementById('phonetic').value = data.phonetic || '';
                    document.getElementById('pronunciation').value = data.pronunciation || '';
                    document.getElementById('partOfSpeech').value = data.part_of_speech || '';
                    document.getElementById('synonyms').value = data.synonyms ? data.synonyms.join(', ') : '';
                    document.getElementById('antonyms').value = data.antonyms ? data.antonyms.join(', ') : '';
                    document.getElementById('submitBtn').textContent = 'Update Word';
                    document.getElementById('cancelBtn').style.display = 'inline-block';
                    
                    document.getElementById('wordForm').scrollIntoView({ behavior: 'smooth' });
                })
                .catch(error => {
                    alert('Error loading word: ' + error.message);
                });
        };
        
        document.getElementById('cancelBtn').addEventListener('click', cancelEdit);
        
        function cancelEdit() {
            isEditing = false;
            document.getElementById('formTitle').textContent = 'Add New Word';
            document.getElementById('editId').value = '';
            document.getElementById('wordForm').reset();
            document.getElementById('scheduled').valueAsDate = new Date();
            document.getElementById('submitBtn').textContent = 'Add Word';
            document.getElementById('cancelBtn').style.display = 'none';
        }
        
        async function loadWords() {
            try {
                const {data, error} = await sb
                    .from('words')
                    .select('*')
                    .order('scheduled_for', {ascending: false});
                
                if (error) throw error;
                
                const list = document.getElementById('list');
                
                if (!data || data.length === 0) {
                    list.innerHTML = '<p>No words yet</p>';
                    return;
                }
                
                const today = new Date().toISOString().split('T')[0];
                
                list.innerHTML = '<table><tr><th>Date</th><th>Word</th><th>Part of Speech</th><th>Meaning</th><th>Actions</th></tr>' +
                    data.map(w => {
                        const isToday = w.scheduled_for === today;
                        return `<tr class="${isToday ? 'today-row' : ''}">
                            <td>${w.scheduled_for || 'N/A'} ${isToday ? '<b>(TODAY)</b>' : ''}</td>
                            <td>
                                <b>${w.word}</b>
                                ${w.pronunciation ? `<br><span style="font-size: 12px; color: #666;">${w.pronunciation}</span>` : ''}
                            </td>
                            <td style="font-style: italic; color: #666;">
                                ${w.part_of_speech || '-'}
                                ${w.phonetic ? `<br><span style="font-size: 11px;">${w.phonetic}</span>` : ''}
                            </td>
                            <td>${w.meaning.substring(0, 60)}${w.meaning.length > 60 ? '...' : ''}</td>
                            <td>
                                <button class="btn-edit" onclick="editWord('${w.id}')">Edit</button>
                                <button class="btn-delete" onclick="deleteWord('${w.id}')">Delete</button>
                            </td>
                        </tr>`;
                    }).join('') +
                    '</table>';
                    
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('list').innerHTML = '<p style="color: red;">Error: ' + error.message + '</p>';
            }
        }
        
        window.deleteWord = async (id) => {
            if (!confirm('Delete this word?')) return;
            
            try {
                const {error} = await sb.from('words').delete().eq('id', id);
                if (error) throw error;
                loadWords();
            } catch (error) {
                alert('Delete failed: ' + error.message);
            }
        };
        
        document.getElementById('scheduled').valueAsDate = new Date();
        
        checkAuth().then(ok => { if(ok) loadWords(); });

    async function fetchFromDataMuse(word) {
    try {
        // Get synonyms
        const synResponse = await fetch(`https://api.datamuse.com/words?rel_syn=${word}&max=10`);
        const synonyms = await synResponse.json();
        
        // Get antonyms
        const antResponse = await fetch(`https://api.datamuse.com/words?rel_ant=${word}&max=10`);
        const antonyms = await antResponse.json();
        
        if (synonyms.length > 0) {
            document.getElementById('synonyms').value = synonyms.map(s => s.word).join(', ');
        }
        
        if (antonyms.length > 0) {
            document.getElementById('antonyms').value = antonyms.map(a => a.word).join(', ');
        }
        
        return { synonyms: synonyms.length, antonyms: antonyms.length };
    } catch (error) {
        console.error('DataMuse error:', error);
        return { synonyms: 0, antonyms: 0 };
    }
}

        // Load word count
        async function loadWordCount() {
            try {
                const { count, error } = await sb
                    .from('words')
                    .select('*', { count: 'exact', head: true });
                
                if (error) throw error;
                
                const countElem = document.getElementById('wordCountAdmin');
                if (countElem) {
                    countElem.textContent = count;
                }
            } catch (error) {
                console.error('Error loading word count:', error);
            }
        }
        async function loadWords() {
            try {
                // ... existing code ...
                
                // Update word count after loading
                loadWordCount();  // ‚Üê ADD THIS LINE
                
            } catch (error) {
                console.error('Error:', error);
            }
        }

        async function loadSiteStats() {
    try {
        // Total words
        const { count: wordCount } = await supabase
            .from('words')
            .select('*', { count: 'exact', head: true });
        
        // Total views
        const { data: words } = await supabase
            .from('words')
            .select('views');
        
        const totalViews = words ? words.reduce((sum, w) => sum + (w.views || 0), 0) : 0;
        
        // Total subscribers
        const { count: subCount } = await supabase
            .from('subscribers')
            .select('*', { count: 'exact', head: true });
        
        // Animate counts
        animateCount(document.getElementById('totalWords'), 0, wordCount || 0, 1000);
        animateCount(document.getElementById('totalViews'), 0, totalViews, 1500);
        animateCount(document.getElementById('totalSubscribers'), 0, subCount || 0, 1200);
        
    } catch (error) {
        console.error('Error loading stats:', error);
    }
}
    </script>
</body>
</html>